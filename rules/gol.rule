n_states: 2
neighbourhood_region_shape: MOORE
neighbourhood_region_size: 1

// Variants: rotations, mirror, rotations + mirror
//   rotations: all four rotations of the pattern are valid
//   mirror: all two mirrors of the pattern are valid, ie: vertical and horizontal
//   rotations + mirror: all permutations of the four rotations and two mirrors of the pattern are
//                         valid
//
// eg: rotations:
// -#-     #--     --#     ---
// -#-  ,  -##  ,  -#-  ,  ##-
// #--     ---     -#-     --#
//
// eg: mirror:
// -#-     -#-     #--     --#
// -#-  ,  -#-  ,  -#-  ,  -#-
// #--     --#     -#-     -#-
//
// eg: rotations + mirror:
//   -#-     #--     --#     ---     -#-     ---     #--     --#     #--     --#     -#-     ---     --#     ---     -#-     #--
// [ -#-  ,  -##  ,  -#-  ,  ##- ],[ -#-  ,  -##  ,  -#-  ,  ##- ],[ -#-  ,  ##-  ,  -#-  ,  -## ],[ -#-  ,  ##-  ,  -#-  ,  -## ]
//   #--     ---     -#-     --#     --#     #--     -#-     ---     -#-     ---     --#     #--     -#-     --#     #--     ---

// # Rule pattern matching
//
// Rules are defined case by case, with pattern matching to simplify and reduce the number of cases
//   needed.

// A rule pattern is defined with:
//   Result: s
// Where s is the resulting state, if this pattern matches.
//
// Following this is the pattern, written out as each cell-state in the neighbourhood region
//   (including the center), left-to-right, top-to-bottom, separated by whitespace.  Cells can be
//   represented by a wildcard: '*' if the state value does not need to be matched for this pattern.
//
// Optional conditions can be added after the pattern:
//   - count_matching: [n], [cond]
//     The pattern only matches if the count of wildcard states equalling n compared with cond is
//       true.  (Useful for Game Of Life like CAs.)

// Dies under-population
Result: 0
* * *
* 1 *
* * *
count_matching: 1, < 2

// Survives
Result: 1
* * *
* 1 *
* * *
count_matching: 1, < 4

// Dies overpopulation
Result: 0
* * *
* 1 *
* * *
count_matching: 1, < 4

Result: 1
* * *
* 0 *
* * *
count_matching: 1, 3
